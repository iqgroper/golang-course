
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">redditclone/pkg/handlers/posts.go (20.0%)</option>
				
				<option value="file1">redditclone/pkg/handlers/user.go (0.0%)</option>
				
				<option value="file2">redditclone/pkg/posts/comment_mongo_repo.go (0.0%)</option>
				
				<option value="file3">redditclone/pkg/posts/comment_repo_mock.go (12.0%)</option>
				
				<option value="file4">redditclone/pkg/posts/posts_mongo_repo.go (70.0%)</option>
				
				<option value="file5">redditclone/pkg/posts/posts_repo_mock.go (47.8%)</option>
				
				<option value="file6">redditclone/pkg/posts/repo.go (12.0%)</option>
				
				<option value="file7">redditclone/pkg/user/mysql_repo.go (60.7%)</option>
				
				<option value="file8">redditclone/pkg/user/repo.go (0.0%)</option>
				
				<option value="file9">redditclone/pkg/user/user_repo_mock.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "redditclone/pkg/posts"
        "redditclone/pkg/session"

        "github.com/gorilla/mux"
        "github.com/sirupsen/logrus"
)

type PostsHandler struct {
        PostsRepo    posts.PostRepo
        CommentsRepo posts.CommentRepo
        Logger       *logrus.Entry
}

func (h *PostsHandler) AddPost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error reading body")
                return
        }</span>

        <span class="cov0" title="0">newPost := &amp;posts.NewPost{}
        errorUnmarshal := json.Unmarshal(body, newPost)
        if errorUnmarshal != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error unmarshling new post:", errorUnmarshal.Error())
                http.Error(w, fmt.Sprintf(`error unmarshling new post: %s`, errorUnmarshal.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">sess, errSess := session.SessionFromContext(r.Context())
        if errSess != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error getting session in AddPost:", errSess.Error())
                http.Error(w, fmt.Sprintf(`error getting session in AddPost: %s`, errSess.Error()), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">newPost.Author = *sess.User

        addedPost, errAdd := h.PostsRepo.Add(newPost)
        if errAdd != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error adding post:", errAdd.Error())
                http.Error(w, fmt.Sprintf(`error adding post: %s`, errAdd.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">resp, errEncoding := json.Marshal(addedPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(resp)</span>
}

func (h *PostsHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov8" title="1">{
                h.Logger.Println("no post_id in query in GetByID")
                http.Error(w, "no post_id in query in GetByID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">foundPost, errFind := h.PostsRepo.GetByID(postID)
        if errFind != nil </span><span class="cov8" title="1">{
                h.Logger.Println("no such post in repo.getbyid:", errFind.Error())
                http.Error(w, fmt.Sprintln("no such post in repo.getbyid:", errFind.Error()), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">foundPost.Views += 1

        resp, errEncoding := json.Marshal(foundPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Write(resp)</span>
}

func (h *PostsHandler) AddComment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no post_id in query in AddComment")
                http.Error(w, "no post_id in query in AddComment", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sess, errSess := session.SessionFromContext(r.Context())
        if errSess != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error getting session in AddComment:", errSess.Error())
                http.Error(w, fmt.Sprintf(`error getting session in AddComment: %s`, errSess.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">defer r.Body.Close()

        bodyRaw, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error reading body in AddComment")
                return
        }</span>

        <span class="cov0" title="0">body := &amp;struct{ Comment string }{}

        errorUnmarshal := json.Unmarshal(bodyRaw, body)
        if errorUnmarshal != nil </span><span class="cov0" title="0">{
                fmt.Println("error unmarshling in AddComment:", errorUnmarshal.Error())
                return
        }</span>

        <span class="cov0" title="0">if len(body.Comment) == 0 </span><span class="cov0" title="0">{

                http.Error(w, `{"errors":[{"location":"body","param":"comment","msg":"is required"}]}`, http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov0" title="0">_, errAdd := h.CommentsRepo.Add(postID, body.Comment, sess.User)
        if errAdd != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error adding in AddComment:", errAdd.Error())
                http.Error(w, fmt.Sprintf(`error addinc comment in AddComment: %s`, errAdd.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">foundPost, errFind := h.PostsRepo.GetByID(postID)
        if errFind != nil </span><span class="cov0" title="0">{
                h.Logger.Println("cant find post in AddComment:", errFind.Error())
                http.Error(w, fmt.Sprintln("cant find post in AddComment:", errFind.Error()), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">resp, errEncoding := json.Marshal(foundPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(resp)</span>
}

func (h *PostsHandler) DeleteComment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no post_id in query in DeleteComment")
                http.Error(w, "no post_id in query in DeleteComment", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">commentID, ok := vars["comment_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no comment_id in query in DeleteComment")
                http.Error(w, "no comment_id in query in DeleteComment", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">ok, err := h.CommentsRepo.Delete(postID, commentID)
        if !ok || err != nil </span><span class="cov0" title="0">{
                h.Logger.Println("cant delete a comment in DeleteComment", err.Error())
                http.Error(w, "cant delete a comment in DeleteComment", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">foundPost, errFind := h.PostsRepo.GetByID(postID)
        if errFind != nil </span><span class="cov0" title="0">{
                h.Logger.Println("cant find post in DeleteComment:", errFind.Error())
                http.Error(w, fmt.Sprintln("cant find post in DeleteComment:", errFind.Error()), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">newComments, errGetAll := h.CommentsRepo.GetAll(foundPost.ID)
        if errGetAll != nil </span><span class="cov0" title="0">{
                h.Logger.Println("cant GetAll in DeleteComment:", errGetAll.Error())
                http.Error(w, fmt.Sprintln("cant GetAll in DeleteComment:", errGetAll.Error()), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">foundPost.Comments = newComments

        resp, errEncoding := json.Marshal(foundPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(resp)</span>
}

func (h *PostsHandler) UpVote(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no post_id in query in UpVote")
                http.Error(w, "no post_id in query in UpVote", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sess, errSess := session.SessionFromContext(r.Context())
        if errSess != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error getting session in UpVote:", errSess.Error())
                http.Error(w, fmt.Sprintf(`error getting session in UpVote: %s`, errSess.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">foundPost, err := h.PostsRepo.UpVote(postID, sess.User.Login)
        if err == posts.ErrNoCanDo </span><span class="cov0" title="0">{
                h.Logger.Println("no such post in UpVote:", err.Error(), " redirected to unvote")
                http.Redirect(w, r, fmt.Sprintf("/api/post/%s/unvote", postID), http.StatusFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.Logger.Println(err.Error())
                http.Error(w, "UpVote:"+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">resp, errEncoding := json.Marshal(foundPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(resp)</span>
}

func (h *PostsHandler) DownVote(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no post_id in query in DownVote")
                http.Error(w, "no post_id in query in DownVote", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sess, errSess := session.SessionFromContext(r.Context())
        if errSess != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error getting session in DownVote:", errSess.Error())
                http.Error(w, fmt.Sprintf(`error getting session in DownVote: %s`, errSess.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">foundPost, err := h.PostsRepo.DownVote(postID, sess.User.Login)
        if err == posts.ErrNoCanDo </span><span class="cov0" title="0">{
                h.Logger.Println("in DownVote:", err.Error(), " redirected to unvote")
                http.Redirect(w, r, fmt.Sprintf("/api/post/%s/unvote", postID), http.StatusFound)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.Logger.Println(err.Error())
                http.Error(w, "DownVote:"+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">resp, errEncoding := json.Marshal(foundPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(resp)</span>
}

func (h *PostsHandler) DeletePost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no post_id in query in DeletePost")
                http.Error(w, "no post_id in query in DeletePost", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">_, errDel := h.PostsRepo.Delete(postID)
        if errDel != nil </span><span class="cov0" title="0">{
                h.Logger.Println("in DeletePost:", errDel.Error())
                http.Error(w, "in DeletePost: "+errDel.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">resp, errMar := json.Marshal(map[string]string{"message": "success"})
        if errMar != nil </span><span class="cov0" title="0">{
                h.Logger.Println("cant marshal in DeleteCommentByPost", errMar.Error())
                http.Error(w, "cant marshal in DeleteCommentByPost "+errMar.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write([]byte(resp))</span>
}

func (h *PostsHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        postList, errGetting := h.PostsRepo.GetAll()
        if errGetting != nil </span><span class="cov8" title="1">{
                h.Logger.Println(errGetting)
                w.Write([]byte("[]"))
                return
        }</span>

        <span class="cov8" title="1">resp, errEncoding := json.Marshal(postList)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Write(resp)</span>
}

func (h *PostsHandler) GetByCategory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        categoryName, ok := vars["category_name"]
        if !ok </span><span class="cov8" title="1">{
                h.Logger.Println("no category_name in query")
                http.Error(w, "no category_name in query", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">postList, errGetting := h.PostsRepo.GetAllByCategory(categoryName)
        if errGetting != nil </span><span class="cov8" title="1">{
                h.Logger.Println(errGetting)
                w.Write([]byte("[]"))
                return
        }</span>

        <span class="cov8" title="1">resp, errEncoding := json.Marshal(postList)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Write(resp)</span>
}

func (h *PostsHandler) GetAllByUser(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        userLogin, ok := vars["user_login"]
        if !ok </span><span class="cov8" title="1">{
                h.Logger.Println("no user_login in query")
                http.Error(w, "no user_login in query", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">postList, errGetting := h.PostsRepo.GetByUser(userLogin)
        if errGetting != nil </span><span class="cov8" title="1">{
                h.Logger.Println(errGetting)
                w.Write([]byte("[]"))
                return
        }</span>

        <span class="cov8" title="1">resp, errEncoding := json.Marshal(postList)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Write(resp)</span>
}

func (h *PostsHandler) UnVote(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)

        postID, ok := vars["post_id"]
        if !ok </span><span class="cov0" title="0">{
                h.Logger.Println("no post_id in query in UnVote")
                http.Error(w, "no post_id in query in UnVote", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sess, errSess := session.SessionFromContext(r.Context())
        if errSess != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error getting session in UnVote:", errSess.Error())
                http.Error(w, fmt.Sprintf(`error getting session in UnVote: %s`, errSess.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">foundPost, errFind := h.PostsRepo.UnVote(postID, sess.User.Login)
        if errFind != nil </span><span class="cov0" title="0">{
                h.Logger.Println("no such post in UnVote:", errFind.Error())
                http.Error(w, fmt.Sprintln("no such post in UnVote:", errFind.Error()), http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">resp, errEncoding := json.Marshal(foundPost)
        if errEncoding != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error marshalling post:", errEncoding.Error())
                http.Error(w, fmt.Sprintf(`error marshalling post: %s`, errEncoding.Error()), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(resp)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "redditclone/pkg/session"
        "redditclone/pkg/user"

        "github.com/sirupsen/logrus"
)

type UserHandler struct {
        Logger   *logrus.Entry
        UserRepo user.UserRepo
        Sessions *session.SessionsRedisManager
}

func getNameAndPass(r *http.Request) (*user.NewUser, error) <span class="cov0" title="0">{
        defer r.Body.Close()

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error reading body")
                return nil, err
        }</span>

        <span class="cov0" title="0">newUser := &amp;user.NewUser{}
        errorUnmarshal := json.Unmarshal(body, newUser)
        if errorUnmarshal != nil </span><span class="cov0" title="0">{
                fmt.Println("error unmarshling: ", errorUnmarshal.Error())
                return nil, errorUnmarshal
        }</span>
        <span class="cov0" title="0">return newUser, nil</span>
}

func (h *UserHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        newUser, errGetting := getNameAndPass(r)
        if errGetting != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error in Login:", errGetting.Error())
                http.Error(w, fmt.Sprintf(`Bad Login data format: %s`, errGetting.Error()), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userToLogIn, err := h.UserRepo.Authorize(newUser.Username, newUser.Password)
        if err == user.ErrNoUser </span><span class="cov0" title="0">{
                h.Logger.Println("error in Login:", err.Error())
                http.Error(w, `{"message":"user not found"}`, http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">if err == user.ErrBadPass </span><span class="cov0" title="0">{
                h.Logger.Println("error in Login:", err.Error())
                http.Error(w, `{"message": "invalid password"}`, http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error in Login:", err.Error())
                http.Error(w, `{"message": "something went wrong"}`, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">sess, _ := h.Sessions.Create(w, userToLogIn)
        h.Logger.WithFields(logrus.Fields{
                "user": userToLogIn.Login,
                "task": "logged in",
        }).Info("Login")

        w.Write([]byte(fmt.Sprintf(`{"token": "%s"}`, sess.ID)))</span>
}

func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        newUser, errGetting := getNameAndPass(r)
        if errGetting != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error in Login:", errGetting.Error())
                http.Error(w, fmt.Sprintf(`Bad Login data format: %s`, errGetting.Error()), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.Logger.WithFields(logrus.Fields{
                "method": r.Method,
                "body":   fmt.Sprintf(`username: %s, password: %s`, newUser.Username, newUser.Password),
        }).Info("Register")

        createdUser, errRegister := h.UserRepo.Register(newUser.Username, newUser.Password)
        if errRegister == user.ErrUserExists </span><span class="cov0" title="0">{
                h.Logger.Println("error registring user: ", errRegister.Error())
                http.Error(w, fmt.Sprintf(`{"errors":[{"location":"body","param":"username","value":"%s","msg":"%s"}]}`, newUser.Username, errRegister.Error()), http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov0" title="0">newSession, SessErr := h.Sessions.Create(w, createdUser)
        if SessErr != nil </span><span class="cov0" title="0">{
                h.Logger.Println("error creating session: ", SessErr.Error())
                http.Error(w, "Error creating session", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">w.Write([]byte(fmt.Sprintf(`{"token": "%s"}`, newSession.ID)))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package posts

import (
        "context"
        "fmt"
        "log"
        "redditclone/pkg/user"
        "strconv"
        "time"

        "github.com/pkg/errors"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type CommentMongoRepository struct {
        DB     *mongo.Collection
        Ctx    *context.Context
        Cancel context.CancelFunc
        lastID int
}

func NewMongoRepo(db *mongo.Collection, ctx *context.Context, cancel context.CancelFunc) *CommentMongoRepository <span class="cov0" title="0">{
        return &amp;CommentMongoRepository{
                DB:     db,
                Ctx:    ctx,
                Cancel: cancel,
        }
}</span>

func (repo *CommentMongoRepository) getPostByID(id string) (*Post, error) <span class="cov0" title="0">{
        result := &amp;Post{}
        objectId, errGettingObject := primitive.ObjectIDFromHex(id)
        if errGettingObject != nil </span><span class="cov0" title="0">{
                log.Println("Error getting object from id:", id)
                return nil, errGettingObject
        }</span>
        <span class="cov0" title="0">filter := bson.M{"_id": objectId}
        err := repo.DB.FindOne(*repo.Ctx, filter).Decode(&amp;result)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (repo *CommentMongoRepository) GetAll(post_id string) ([]*Comment, error) <span class="cov0" title="0">{

        post, err := repo.getPostByID(post_id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error getting comments", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return post.Comments, nil</span>
}

func (repo *CommentMongoRepository) Add(post_id string, body string, user *user.User) (*Comment, error) <span class="cov0" title="0">{

        newComment := &amp;Comment{
                ID:      strconv.Itoa(repo.lastID),
                Body:    body,
                Created: time.Now(),
                Author:  user,
                PostID:  post_id,
        }
        repo.lastID++

        post, err := repo.getPostByID(post_id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error getting comments", err.Error())
                return nil, errors.Wrap(err, "adding comment")
        }</span>

        <span class="cov0" title="0">post.Comments = append(post.Comments, newComment)

        id, _ := primitive.ObjectIDFromHex(post_id)
        update := bson.M{
                "$set": bson.M{
                        "Comments": post.Comments,
                },
        }
        res := repo.DB.FindOneAndUpdate(*repo.Ctx, bson.M{"_id": id}, update)

        if res.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov0" title="0"> if res.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal("FindOneAndUpdate err", res.Err().Error())
        }</span>

        <span class="cov0" title="0">return newComment, nil</span>
}

func (repo *CommentMongoRepository) Delete(post_id, comment_id string) (bool, error) <span class="cov0" title="0">{
        post, err := repo.getPostByID(post_id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error deleting a comment", err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">comments := post.Comments

        removeID := -1
        for idx, comment := range comments </span><span class="cov0" title="0">{
                if comment.ID == comment_id </span><span class="cov0" title="0">{
                        removeID = idx
                }</span>
        }

        <span class="cov0" title="0">if removeID &lt; len(comments)-1 </span><span class="cov0" title="0">{
                copy(comments[removeID:], comments[removeID+1:])
        }</span>
        <span class="cov0" title="0">comments[len(comments)-1] = nil
        comments = comments[:len(comments)-1]

        post.Comments = comments

        id, _ := primitive.ObjectIDFromHex(post_id)

        update := bson.M{
                "$set": bson.M{
                        "Comments": post.Comments,
                },
        }
        res := repo.DB.FindOneAndUpdate(*repo.Ctx, bson.M{"_id": id}, update)

        if res.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return false, ErrNoPost
        }</span> else<span class="cov0" title="0"> if res.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal("FindOneAndUpdate err", res.Err().Error())
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: posts/comment.go

// Package posts is a generated GoMock package.
package posts

import (
        user "redditclone/pkg/user"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockCommentRepo is a mock of CommentRepo interface.
type MockCommentRepo struct {
        ctrl     *gomock.Controller
        recorder *MockCommentRepoMockRecorder
}

// MockCommentRepoMockRecorder is the mock recorder for MockCommentRepo.
type MockCommentRepoMockRecorder struct {
        mock *MockCommentRepo
}

// NewMockCommentRepo creates a new mock instance.
func NewMockCommentRepo(ctrl *gomock.Controller) *MockCommentRepo <span class="cov8" title="1">{
        mock := &amp;MockCommentRepo{ctrl: ctrl}
        mock.recorder = &amp;MockCommentRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentRepo) EXPECT() *MockCommentRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockCommentRepo) Add(post_id, body string, user *user.User) (*Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Add", post_id, body, user)
        ret0, _ := ret[0].(*Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Add indicates an expected call of Add.
func (mr *MockCommentRepoMockRecorder) Add(post_id, body, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockCommentRepo)(nil).Add), post_id, body, user)
}</span>

// Delete mocks base method.
func (m *MockCommentRepo) Delete(post_id, comment_id string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", post_id, comment_id)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockCommentRepoMockRecorder) Delete(post_id, comment_id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCommentRepo)(nil).Delete), post_id, comment_id)
}</span>

// GetAll mocks base method.
func (m *MockCommentRepo) GetAll(post_id string) ([]*Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", post_id)
        ret0, _ := ret[0].([]*Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockCommentRepoMockRecorder) GetAll(post_id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockCommentRepo)(nil).GetAll), post_id)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package posts

import (
        "context"
        "fmt"
        "log"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.mongodb.org/mongo-driver/mongo/readpref"
)

type PostsMongoRepository struct {
        DB     *mongo.Collection
        Ctx    *context.Context
        Cancel context.CancelFunc
}

func NewMongoRepository() *PostsMongoRepository <span class="cov0" title="0">{
        client, errMongo := mongo.NewClient(options.Client().ApplyURI("mongodb://localhost"))
        if errMongo != nil </span><span class="cov0" title="0">{
                panic(errMongo)</span>
        }
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        err := client.Connect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">errMongo = client.Ping(ctx, readpref.Primary())
        if errMongo != nil </span><span class="cov0" title="0">{
                panic(errMongo)</span>

        }

        <span class="cov0" title="0">collection := client.Database("coursera").Collection("posts")
        return &amp;PostsMongoRepository{DB: collection, Ctx: &amp;ctx, Cancel: cancel}</span>
}

func (repo *PostsMongoRepository) GetAll() ([]*Post, error) <span class="cov8" title="1">{
        cur, err := repo.DB.Find(*repo.Ctx, bson.D{})
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("ERROR GETTING ALL POSTS", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">PostList := make([]*Post, 0, 5)

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        defer cur.Close(ctx)
        for cur.Next(ctx) </span><span class="cov8" title="1">{
                newPost := &amp;Post{}
                err := cur.Decode(newPost)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error decoding in GetAllPosts")
                        return nil, fmt.Errorf("error decoding in GetAllPosts")
                }</span>
                <span class="cov8" title="1">PostList = append(PostList, newPost)</span>
        }
        <span class="cov8" title="1">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">return PostList, nil</span>
}

func (repo *PostsMongoRepository) GetByID(id string) (*Post, error) <span class="cov8" title="1">{
        result := &amp;Post{}
        objectId, errGettingObject := primitive.ObjectIDFromHex(id)
        if errGettingObject != nil </span><span class="cov8" title="1">{
                log.Println("Error getting object from id:", id)
                return nil, errGettingObject
        }</span>
        <span class="cov8" title="1">filter := bson.M{"_id": objectId}
        err := repo.DB.FindOne(*repo.Ctx, filter).Decode(&amp;result)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                log.Println("FindOne", err)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (repo *PostsMongoRepository) Add(item *NewPost) (*Post, error) <span class="cov0" title="0">{

        newPost := &amp;Post{
                Title:            item.Title,
                Score:            1,
                VotesList:        []VoteStruct{{item.Author.Login, 1}},
                Category:         item.Category,
                Comments:         make([]*Comment, 0, 10),
                CreatedDTTM:      time.Now(),
                Text:             item.Text,
                URL:              item.URL,
                Type:             item.Type,
                UpvotePercentage: 100,
                Views:            0,
                Author:           AuthorStruct{item.Author.Login, item.Author.ID},
        }

        result, err := repo.DB.InsertOne(*repo.Ctx, newPost)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("ADDING POST", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if id, ok := result.InsertedID.(primitive.ObjectID); ok </span><span class="cov0" title="0">{
                ID := id.Hex()
                newPost.ID = ID
                update := bson.M{
                        "$set": bson.M{"ID": ID},
                }
                res := repo.DB.FindOneAndUpdate(*repo.Ctx, bson.M{"_id": id}, update)
                if res.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        fmt.Println("record does not exist")
                        return nil, ErrNoPost
                }</span> else<span class="cov0" title="0"> if res.Err() != nil </span><span class="cov0" title="0">{
                        log.Fatal("FindOneAndUpdate err", res.Err().Error())
                }</span>
                <span class="cov0" title="0">return newPost, nil</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("id assertion failed")
        }</span>
}

func (repo *PostsMongoRepository) Delete(id string) (bool, error) <span class="cov8" title="1">{
        objectId, errGettingObject := primitive.ObjectIDFromHex(id)
        if errGettingObject != nil </span><span class="cov8" title="1">{
                log.Println("Error getting object from id")
                return false, errGettingObject
        }</span>
        <span class="cov8" title="1">filter := bson.M{"_id": objectId}

        _, err := repo.DB.DeleteOne(*repo.Ctx, filter)
        if err != nil </span><span class="cov8" title="1">{
                log.Print("DeleteOne", err)
                return false, err
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

func (repo *PostsMongoRepository) GetByUser(user_login string) ([]*Post, error) <span class="cov8" title="1">{

        filter := bson.M{
                "author": bson.M{
                        "username": user_login,
                        "id": bson.M{
                                "$regex": primitive.Regex{
                                        Pattern: "[0-9a-z]+",
                                        Options: "i",
                                },
                        },
                },
        }

        cur, err := repo.DB.Find(*repo.Ctx, filter)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("ERR GETTING ALL POSTS BY USER", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">PostList := make([]*Post, 0, 5)

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        defer cur.Close(ctx)
        for cur.Next(ctx) </span><span class="cov8" title="1">{
                newPost := &amp;Post{}
                err := cur.Decode(newPost)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error decoding in getting all posts by user")
                        return nil, fmt.Errorf("error decoding in getting all posts by user")
                }</span>
                <span class="cov8" title="1">PostList = append(PostList, newPost)</span>
        }
        <span class="cov8" title="1">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">return PostList, nil</span>
}

func (repo *PostsMongoRepository) GetAllByCategory(category string) ([]*Post, error) <span class="cov8" title="1">{

        filter := bson.M{"category": category}

        cur, err := repo.DB.Find(*repo.Ctx, filter)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("ERR GetAllByCategory", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">PostList := make([]*Post, 0, 5)

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        defer cur.Close(ctx)
        for cur.Next(ctx) </span><span class="cov8" title="1">{
                newPost := &amp;Post{}
                err := cur.Decode(newPost)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error decoding in GetAllPosts")
                        return nil, fmt.Errorf("error decoding in GetAllPosts")
                }</span>
                <span class="cov8" title="1">PostList = append(PostList, newPost)</span>
        }
        <span class="cov8" title="1">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">return PostList, nil</span>
}

func (repo *PostsMongoRepository) UpVote(post_id string, username string) (*Post, error) <span class="cov8" title="1">{

        result := &amp;Post{}
        objectId, errGettingObject := primitive.ObjectIDFromHex(post_id)
        if errGettingObject != nil </span><span class="cov8" title="1">{
                log.Println("Error getting object from id:", post_id)
                return nil, errGettingObject
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": objectId}
        err := repo.DB.FindOne(*repo.Ctx, filter).Decode(result)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                log.Fatal("find one err UpVote", err)
        }</span>

        <span class="cov8" title="1">for _, voter := range result.VotesList </span><span class="cov8" title="1">{
                if voter.User == username &amp;&amp; voter.Vote == 1 </span><span class="cov8" title="1">{
                        return nil, ErrNoCanDo
                }</span>
                <span class="cov8" title="1">if voter.User == username &amp;&amp; voter.Vote == -1 </span><span class="cov8" title="1">{
                        _, _ = repo.UnVote(post_id, username)
                        result, _ = repo.UpVote(post_id, username)
                        return result, nil
                }</span>
        }

        <span class="cov8" title="1">result.Score++
        result.VotesList = append(result.VotesList, VoteStruct{username, 1})
        result.UpvotePercentage = percetageCount(result.VotesList)

        update := bson.M{
                "$set": bson.M{
                        "Score":            result.Score,
                        "UpvotePercentage": result.UpvotePercentage,
                        "VotesList":        result.VotesList,
                },
        }
        res := repo.DB.FindOneAndUpdate(*repo.Ctx, filter, update)

        if res.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if res.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal(res.Err())
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (repo *PostsMongoRepository) DownVote(post_id string, username string) (*Post, error) <span class="cov8" title="1">{

        result := &amp;Post{}
        objectId, errGettingObject := primitive.ObjectIDFromHex(post_id)
        if errGettingObject != nil </span><span class="cov8" title="1">{
                log.Println("Error getting object from id:", post_id)
                return nil, errGettingObject
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": objectId}
        err := repo.DB.FindOne(*repo.Ctx, filter).Decode(result)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">for _, voter := range result.VotesList </span><span class="cov8" title="1">{
                if voter.User == username &amp;&amp; voter.Vote == -1 </span><span class="cov8" title="1">{
                        return nil, ErrNoCanDo
                }</span>
                <span class="cov8" title="1">if voter.User == username &amp;&amp; voter.Vote == 1 </span><span class="cov8" title="1">{
                        _, _ = repo.UnVote(post_id, username)
                        result, _ = repo.DownVote(post_id, username)
                        return result, nil
                }</span>
        }

        <span class="cov8" title="1">result.Score--
        result.VotesList = append(result.VotesList, VoteStruct{username, -1})
        result.UpvotePercentage = percetageCount(result.VotesList)

        update := bson.M{
                "$set": bson.M{
                        "Score":            result.Score,
                        "UpvotePercentage": result.UpvotePercentage,
                        "VotesList":        result.VotesList,
                },
        }
        res := repo.DB.FindOneAndUpdate(*repo.Ctx, filter, update)

        if res.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if res.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal(res.Err())
        }</span>

        <span class="cov8" title="1">return result, nil</span>

}

func (repo *PostsMongoRepository) UnVote(post_id string, username string) (*Post, error) <span class="cov8" title="1">{

        result := &amp;Post{}
        objectId, errGettingObject := primitive.ObjectIDFromHex(post_id)
        if errGettingObject != nil </span><span class="cov8" title="1">{
                log.Println("Error getting object from id:", post_id)
                return nil, errGettingObject
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": objectId}
        err := repo.DB.FindOne(*repo.Ctx, filter).Decode(result)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                log.Fatal("FindOne err UnVote", err.Error())
        }</span>

        <span class="cov8" title="1">vote := 0
        indexDel := -1
        for idx, voter := range result.VotesList </span><span class="cov8" title="1">{
                if voter.User == username </span><span class="cov8" title="1">{
                        vote = voter.Vote
                        indexDel = idx
                        break</span>
                }
        }
        <span class="cov8" title="1">if indexDel == -1 </span><span class="cov0" title="0">{
                return nil, ErrNoPost
        }</span>

        <span class="cov8" title="1">result.Score -= vote

        if indexDel &lt; len(result.VotesList)-1 </span><span class="cov0" title="0">{
                copy(result.VotesList[indexDel:], result.VotesList[indexDel+1:])
        }</span>
        <span class="cov8" title="1">result.VotesList[len(result.VotesList)-1] = VoteStruct{}
        result.VotesList = result.VotesList[:len(result.VotesList)-1]

        result.UpvotePercentage = percetageCount(result.VotesList)
        // result.IdMongo = objectId

        update := bson.M{
                "$set": bson.M{
                        "Score":            result.Score,
                        "UpvotePercentage": result.UpvotePercentage,
                        "VotesList":        result.VotesList,
                },
        }
        res := repo.DB.FindOneAndUpdate(*repo.Ctx, filter, update)

        if res.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                fmt.Println("record does not exist")
                return nil, ErrNoPost
        }</span> else<span class="cov8" title="1"> if res.Err() != nil </span><span class="cov0" title="0">{
                log.Fatal("FindOneAndUpdate err UnVote", res.Err().Error())
        }</span>

        <span class="cov8" title="1">return result, nil</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: posts/posts.go

// Package posts is a generated GoMock package.
package posts

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockPostRepo is a mock of PostRepo interface.
type MockPostRepo struct {
        ctrl     *gomock.Controller
        recorder *MockPostRepoMockRecorder
}

// MockPostRepoMockRecorder is the mock recorder for MockPostRepo.
type MockPostRepoMockRecorder struct {
        mock *MockPostRepo
}

// NewMockPostRepo creates a new mock instance.
func NewMockPostRepo(ctrl *gomock.Controller) *MockPostRepo <span class="cov8" title="1">{
        mock := &amp;MockPostRepo{ctrl: ctrl}
        mock.recorder = &amp;MockPostRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostRepo) EXPECT() *MockPostRepoMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockPostRepo) Add(item *NewPost) (*Post, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Add", item)
        ret0, _ := ret[0].(*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Add indicates an expected call of Add.
func (mr *MockPostRepoMockRecorder) Add(item interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockPostRepo)(nil).Add), item)
}</span>

// Delete mocks base method.
func (m *MockPostRepo) Delete(post_id string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", post_id)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPostRepoMockRecorder) Delete(post_id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPostRepo)(nil).Delete), post_id)
}</span>

// DownVote mocks base method.
func (m *MockPostRepo) DownVote(post_id, username string) (*Post, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DownVote", post_id, username)
        ret0, _ := ret[0].(*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DownVote indicates an expected call of DownVote.
func (mr *MockPostRepoMockRecorder) DownVote(post_id, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownVote", reflect.TypeOf((*MockPostRepo)(nil).DownVote), post_id, username)
}</span>

// GetAll mocks base method.
func (m *MockPostRepo) GetAll() ([]*Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll")
        ret0, _ := ret[0].([]*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockPostRepoMockRecorder) GetAll() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockPostRepo)(nil).GetAll))
}</span>

// GetAllByCategory mocks base method.
func (m *MockPostRepo) GetAllByCategory(category string) ([]*Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllByCategory", category)
        ret0, _ := ret[0].([]*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllByCategory indicates an expected call of GetAllByCategory.
func (mr *MockPostRepoMockRecorder) GetAllByCategory(category interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllByCategory", reflect.TypeOf((*MockPostRepo)(nil).GetAllByCategory), category)
}</span>

// GetByID mocks base method.
func (m *MockPostRepo) GetByID(post_id string) (*Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", post_id)
        ret0, _ := ret[0].(*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockPostRepoMockRecorder) GetByID(post_id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockPostRepo)(nil).GetByID), post_id)
}</span>

// GetByUser mocks base method.
func (m *MockPostRepo) GetByUser(user_login string) ([]*Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUser", user_login)
        ret0, _ := ret[0].([]*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUser indicates an expected call of GetByUser.
func (mr *MockPostRepoMockRecorder) GetByUser(user_login interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUser", reflect.TypeOf((*MockPostRepo)(nil).GetByUser), user_login)
}</span>

// UnVote mocks base method.
func (m *MockPostRepo) UnVote(post_id, username string) (*Post, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UnVote", post_id, username)
        ret0, _ := ret[0].(*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UnVote indicates an expected call of UnVote.
func (mr *MockPostRepoMockRecorder) UnVote(post_id, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnVote", reflect.TypeOf((*MockPostRepo)(nil).UnVote), post_id, username)
}</span>

// UpVote mocks base method.
func (m *MockPostRepo) UpVote(post_id, username string) (*Post, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpVote", post_id, username)
        ret0, _ := ret[0].(*Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpVote indicates an expected call of UpVote.
func (mr *MockPostRepoMockRecorder) UpVote(post_id, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpVote", reflect.TypeOf((*MockPostRepo)(nil).UpVote), post_id, username)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package posts

import (
        "errors"
        "fmt"
        "redditclone/pkg/user"
        "strconv"
        "sync"
        "time"
)

var (
        ErrNoPost  = errors.New("no such post found")
        ErrNoCanDo = errors.New("method not allowed")
)

type PostMemoryRepository struct {
        lastID int
        data   []*Post
        mu     *sync.RWMutex
}

type NewPost struct {
        Type     string
        Title    string
        Text     string
        URL      string
        Category string
        Author   user.User `json:"-"`
}

func NewMemoryRepo() *PostMemoryRepository <span class="cov0" title="0">{
        return &amp;PostMemoryRepository{
                lastID: 0,
                data:   make([]*Post, 0, 10),
                mu:     &amp;sync.RWMutex{},
        }
}</span>

func (repo *PostMemoryRepository) GetAll() ([]*Post, error) <span class="cov0" title="0">{
        return repo.data, nil
}</span>

func (repo *PostMemoryRepository) GetByID(id string) (*Post, error) <span class="cov0" title="0">{
        for _, item := range repo.data </span><span class="cov0" title="0">{
                if item.ID == id </span><span class="cov0" title="0">{
                        return item, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, ErrNoPost</span>
}

func (repo *PostMemoryRepository) GetByUser(user_login string) ([]*Post, error) <span class="cov0" title="0">{
        result := make([]*Post, 0, 10)
        for _, item := range repo.data </span><span class="cov0" title="0">{
                if item.Author.Username == user_login </span><span class="cov0" title="0">{
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoPost
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (repo *PostMemoryRepository) Add(item *NewPost) (*Post, error) <span class="cov0" title="0">{

        newPost := &amp;Post{
                ID:               strconv.Itoa(repo.lastID),
                Title:            item.Title,
                Score:            1,
                VotesList:        []VoteStruct{{item.Author.Login, 1}},
                Category:         item.Category,
                Comments:         make([]*Comment, 0, 10),
                CreatedDTTM:      time.Now(),
                Text:             item.Text,
                URL:              item.URL,
                Type:             item.Type,
                UpvotePercentage: 100,
                Views:            0,
                Author:           AuthorStruct{item.Author.Login, item.Author.ID},
        }
        repo.lastID++

        repo.mu.Lock()
        repo.data = append(repo.data, newPost)
        repo.mu.Unlock()

        return newPost, nil
}</span>

func (repo *PostMemoryRepository) Delete(id string) (bool, error) <span class="cov0" title="0">{
        i := -1
        for idx, item := range repo.data </span><span class="cov0" title="0">{
                if item.ID == id </span><span class="cov0" title="0">{
                        i = idx
                        break</span>
                }
        }
        <span class="cov0" title="0">if i &lt; 0 </span><span class="cov0" title="0">{
                return false, ErrNoPost
        }</span>

        <span class="cov0" title="0">repo.mu.Lock()
        if i &lt; len(repo.data)-1 </span><span class="cov0" title="0">{
                copy(repo.data[i:], repo.data[i+1:])
        }</span>
        <span class="cov0" title="0">repo.data[len(repo.data)-1] = nil
        repo.data = repo.data[:len(repo.data)-1]
        repo.mu.Unlock()

        return true, nil</span>
}

func (repo *PostMemoryRepository) GetAllByCategory(category string) ([]*Post, error) <span class="cov0" title="0">{
        result := make([]*Post, 0, 10)
        for _, item := range repo.data </span><span class="cov0" title="0">{
                if item.Category == category </span><span class="cov0" title="0">{
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoPost
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func percetageCount(votes []VoteStruct) int <span class="cov8" title="1">{
        votesCount := len(votes)
        if votesCount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">positiveVotes := 0
        negativeVotes := 0
        for _, voter := range votes </span><span class="cov8" title="1">{
                if voter.Vote == 1 </span><span class="cov8" title="1">{
                        positiveVotes++
                }</span>

                <span class="cov8" title="1">if voter.Vote == -1 </span><span class="cov8" title="1">{
                        negativeVotes++
                }</span>
        }

        <span class="cov8" title="1">result := (positiveVotes * 100) / votesCount
        if result &lt; 0 </span><span class="cov0" title="0">{
                fmt.Println("NEGATIVE VOTES")
        }</span>

        <span class="cov8" title="1">return result</span>
}

func (repo *PostMemoryRepository) UpVote(post_id, username string) (*Post, error) <span class="cov0" title="0">{
        for indexPost, item := range repo.data </span><span class="cov0" title="0">{
                if item.ID == post_id </span><span class="cov0" title="0">{
                        for _, voter := range item.VotesList </span><span class="cov0" title="0">{
                                if voter.User == username &amp;&amp; voter.Vote == 1 </span><span class="cov0" title="0">{
                                        return nil, ErrNoCanDo
                                }</span>
                                <span class="cov0" title="0">if voter.User == username &amp;&amp; voter.Vote == -1 </span><span class="cov0" title="0">{
                                        repo.data[indexPost], _ = repo.UnVote(post_id, username)
                                        repo.data[indexPost], _ = repo.UpVote(post_id, username)
                                        return repo.data[indexPost], nil
                                }</span>
                        }

                        <span class="cov0" title="0">item.Score += 1

                        item.VotesList = append(item.VotesList, VoteStruct{username, 1})
                        item.UpvotePercentage = percetageCount(item.VotesList)

                        return item, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, ErrNoPost</span>
}

func (repo *PostMemoryRepository) DownVote(post_id, username string) (*Post, error) <span class="cov0" title="0">{
        for indexPost, item := range repo.data </span><span class="cov0" title="0">{
                if item.ID == post_id </span><span class="cov0" title="0">{
                        for _, voter := range item.VotesList </span><span class="cov0" title="0">{
                                if voter.User == username &amp;&amp; voter.Vote == -1 </span><span class="cov0" title="0">{
                                        return nil, ErrNoCanDo
                                }</span>
                                <span class="cov0" title="0">if voter.User == username &amp;&amp; voter.Vote == 1 </span><span class="cov0" title="0">{
                                        repo.data[indexPost], _ = repo.UnVote(post_id, username)
                                        repo.data[indexPost], _ = repo.DownVote(post_id, username)
                                        return repo.data[indexPost], nil
                                }</span>
                        }
                        <span class="cov0" title="0">item.Score -= 1

                        item.VotesList = append(item.VotesList, VoteStruct{username, -1})
                        item.UpvotePercentage = percetageCount(item.VotesList)

                        return item, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, ErrNoPost</span>
}

func (repo *PostMemoryRepository) UnVote(post_id, username string) (*Post, error) <span class="cov0" title="0">{
        postIndexToRemove := -1
        voteIndexToRemove := -1
LOOP:
        for postIdx, item := range repo.data </span><span class="cov0" title="0">{
                if item.ID == post_id </span><span class="cov0" title="0">{
                        postIndexToRemove = postIdx
                        for idx, voter := range item.VotesList </span><span class="cov0" title="0">{
                                if voter.User == username </span><span class="cov0" title="0">{
                                        voteIndexToRemove = idx

                                        item.Score -= voter.Vote

                                        break LOOP</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">repo.mu.Lock()
        if voteIndexToRemove &lt; len(repo.data[postIndexToRemove].VotesList)-1 </span><span class="cov0" title="0">{
                copy(repo.data[postIndexToRemove].VotesList[voteIndexToRemove:], repo.data[postIndexToRemove].VotesList[voteIndexToRemove+1:])
        }</span>
        <span class="cov0" title="0">repo.data[postIndexToRemove].VotesList[len(repo.data[postIndexToRemove].VotesList)-1] = VoteStruct{}
        repo.data[postIndexToRemove].VotesList = repo.data[postIndexToRemove].VotesList[:len(repo.data[postIndexToRemove].VotesList)-1]
        repo.mu.Unlock()

        repo.data[postIndexToRemove].UpvotePercentage = percetageCount(repo.data[postIndexToRemove].VotesList)

        return repo.data[postIndexToRemove], nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package user

import (
        "database/sql"
        "fmt"
        "log"
        "strconv"
)

type UserMysqlRepository struct {
        DB *sql.DB
}

func NewMysqlRepo() *UserMysqlRepository <span class="cov0" title="0">{
        dsn := "root:love@tcp(localhost:3306)/golang?"
        dsn += "charset=utf8"
        dsn += "&amp;interpolateParams=true"

        db, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">db.SetMaxOpenConns(10)

        err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;UserMysqlRepository{DB: db}</span>
}

func (repo *UserMysqlRepository) Authorize(login, pass string) (*User, error) <span class="cov8" title="1">{
        user := &amp;User{}
        err := repo.DB.QueryRow("SELECT id, login, password FROM items WHERE login = ?;", login).
                Scan(&amp;user.ID, &amp;user.Login, &amp;user.Password)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, ErrNoUser
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                log.Println("QueryRowError", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if user.Password != pass </span><span class="cov8" title="1">{
                return nil, ErrBadPass
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (repo *UserMysqlRepository) Register(login, pass string) (*User, error) <span class="cov8" title="1">{
        result, err := repo.DB.Exec(
                "INSERT INTO items (`login`, `password`) VALUES (?, ?)",
                login,
                pass,
        )
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("QueryRow", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">id, _ := result.LastInsertId()

        newUser := &amp;User{
                ID:       strconv.Itoa(int(id)),
                Login:    login,
                Password: pass,
        }

        return newUser, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package user

import (
        "errors"
        "strconv"
        "sync"
)

var (
        ErrNoUser     = errors.New("no user found")
        ErrUserExists = errors.New("already exists")
        ErrBadPass    = errors.New("invald password")
)

type UserMemoryRepository struct {
        data   map[string]*User
        LastID int
        mu     *sync.RWMutex
}

func NewMemoryRepo() *UserMemoryRepository <span class="cov0" title="0">{
        return &amp;UserMemoryRepository{
                data: map[string]*User{
                        "admin": {
                                ID:       strconv.Itoa(0),
                                Login:    "admin",
                                Password: "asdfasdf",
                        },
                },
                LastID: 0,
                mu:     &amp;sync.RWMutex{},
        }
}</span>

func (repo *UserMemoryRepository) Authorize(login, pass string) (*User, error) <span class="cov0" title="0">{
        u, ok := repo.data[login]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoUser
        }</span>

        <span class="cov0" title="0">if u.Password != pass </span><span class="cov0" title="0">{
                return nil, ErrBadPass
        }</span>

        <span class="cov0" title="0">return u, nil</span>
}

func (repo *UserMemoryRepository) Register(login, pass string) (*User, error) <span class="cov0" title="0">{
        _, ok := repo.data[login]
        if ok </span><span class="cov0" title="0">{
                return nil, ErrUserExists
        }</span>

        <span class="cov0" title="0">newUser := &amp;User{
                ID:       strconv.Itoa(repo.LastID),
                Login:    login,
                Password: pass,
        }
        repo.LastID++
        repo.mu.RLock()
        repo.data[login] = newUser
        repo.mu.RUnlock()

        return newUser, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/user/user.go

// Package user is a generated GoMock package.
package user

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserRepo is a mock of UserRepo interface.
type MockUserRepo struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepoMockRecorder
}

// MockUserRepoMockRecorder is the mock recorder for MockUserRepo.
type MockUserRepoMockRecorder struct {
        mock *MockUserRepo
}

// NewMockUserRepo creates a new mock instance.
func NewMockUserRepo(ctrl *gomock.Controller) *MockUserRepo <span class="cov0" title="0">{
        mock := &amp;MockUserRepo{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepo) EXPECT() *MockUserRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Authorize mocks base method.
func (m *MockUserRepo) Authorize(login, pass string) (*User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Authorize", login, pass)
        ret0, _ := ret[0].(*User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Authorize indicates an expected call of Authorize.
func (mr *MockUserRepoMockRecorder) Authorize(login, pass interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Authorize", reflect.TypeOf((*MockUserRepo)(nil).Authorize), login, pass)
}</span>

// Register mocks base method.
func (m *MockUserRepo) Register(login, pass string) (*User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", login, pass)
        ret0, _ := ret[0].(*User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockUserRepoMockRecorder) Register(login, pass interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockUserRepo)(nil).Register), login, pass)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
